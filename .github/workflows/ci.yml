name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  test:
    name: Test & Build
    runs-on: ubuntu-latest
    
    
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Cache Prisma Client
        uses: actions/cache@v4
        with:
          path: |
            node_modules/.prisma
            apps/api/node_modules/.prisma
          key: ${{ runner.os }}-prisma-${{ hashFiles('**/schema.prisma') }}
          restore-keys: |
            ${{ runner.os }}-prisma-

      - name: Setup test database directory
        run: mkdir -p apps/api/test/tmp

      - name: Generate Prisma Client
        run: bun run db:generate
        env:
          DATABASE_URL: file:./test/tmp/ci-test.db

      - name: Run database migrations
        run: bun run db:migrate
        env:
          DATABASE_URL: file:./test/tmp/ci-test.db

      - name: Lint code
        id: lint
        continue-on-error: true
        run: |
          # Run linting and capture exit code
          if bun run lint > lint_output.log 2>&1; then
            echo "lint_passed=true" >> $GITHUB_OUTPUT
            echo "lint_errors=" >> $GITHUB_OUTPUT
            echo "‚úÖ Linting passed - no errors found"
          else
            echo "lint_passed=false" >> $GITHUB_OUTPUT
            echo "‚ùå Linting failed - capturing errors"
            
            # Only capture actual error lines, filter out noise
            grep -E '(error|Error|ERROR|warning|Warning|WARNING)' lint_output.log > lint_errors.log || echo "No specific error patterns found, using full output" > lint_errors.log && cat lint_output.log > lint_errors.log
            
            echo "lint_errors<<EOF" >> $GITHUB_OUTPUT
            cat lint_errors.log >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "--- Captured Lint Errors ---"
            cat lint_errors.log
            echo "---------------------------"
          fi

      - name: Triage and Fix Lint Errors
        if: steps.lint.outputs.lint_passed == 'false'
        id: ai_lint_triage
        run: |
          echo "üîç Calling Gemini API for lint error analysis..."
          
          # Create the prompt file
          cat > lint_prompt.txt << 'EOF'
          You are an expert programmer. Analyze the following linting errors and provide a fix.

          **CRITICAL FORMATTING REQUIREMENTS**:
          - Your response MUST start with either `AUTOMATIC_FIX:` or `MANUAL_SUGGESTION:` on its own line
          - Do NOT include any explanatory text before these keywords
          - These keywords are case-sensitive and must be followed by a colon

          **Instructions**:
          1. If you can provide a safe automatic fix using shell commands (sed, find, etc.), start your response with:
             ```
             AUTOMATIC_FIX:
             your shell commands here
             ```

          2. If automatic fixing is not safe or possible, start your response with:
             ```
             MANUAL_SUGGESTION:
             your markdown suggestion here
             ```

          **Examples**:
          ‚úÖ Good response:
          ```
          AUTOMATIC_FIX:
          sed -i 's/var /const /g' src/*.js
          ```

          ‚ùå Bad response:
          ```
          I can help you fix these linting errors.
          
          AUTOMATIC_FIX:
          sed -i 's/var /const /g' src/*.js
          ```

          **Linting Errors to Fix**:
          ${{ steps.lint.outputs.lint_errors }}
          EOF
          
          # Set API key
          export GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}"
          
          # Create request payload (escape quotes properly)
          PROMPT_CONTENT=$(cat lint_prompt.txt | sed 's/"/\\"/g' | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')
          
          cat > api_request.json << EOF
{
  "contents": [{
    "parts": [{
      "text": "$PROMPT_CONTENT"
    }]
  }]
}
EOF
          
          echo "üì§ Sending request to Gemini API..."
          
          # Call Gemini API
          if curl -s -H "Content-Type: application/json" \
               -H "x-goog-api-key: ${GEMINI_API_KEY}" \
               -d @api_request.json \
               "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent" \
               > gemini_api_response.json 2>&1; then
            
            echo "‚úÖ Gemini API call successful"
            
            # Extract response text
            if command -v jq >/dev/null 2>&1; then
              GEMINI_RESPONSE=$(jq -r '.candidates[0].content.parts[0].text // "No response content"' gemini_api_response.json)
            else
              # Fallback without jq
              GEMINI_RESPONSE=$(grep -o '"text"[^}]*' gemini_api_response.json | head -1 | sed 's/"text"[[:space:]]*:[[:space:]]*"//' | sed 's/"[[:space:]]*$//' || echo "Failed to parse response")
            fi
            
            echo "üìù Raw Gemini Response (first 500 chars):"
            echo "${GEMINI_RESPONSE:0:500}"
            
            # Set output for next step
            echo "gemini-response<<EOF" >> $GITHUB_OUTPUT
            echo "$GEMINI_RESPONSE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
          else
            echo "‚ùå Gemini API call failed"
            cat gemini_api_response.json
            echo "gemini-response=API call failed" >> $GITHUB_OUTPUT
          fi
          
          # Clean up
          rm -f lint_prompt.txt api_request.json gemini_api_response.json

      - name: Handle Gemini Response
        id: handle_gemini_response
        if: steps.lint.outputs.lint_passed == 'false'
        run: |
          RESPONSE="${{ steps.ai_lint_triage.outputs.gemini-response }}"
          
          # üîç Enhanced Debug: Check response details
          echo "‚ïê‚ïê‚ïê DEBUGGING GEMINI RESPONSE ‚ïê‚ïê‚ïê"
          echo "Response variable length: ${#RESPONSE}"
          echo "Response variable set: $([ -n "$RESPONSE" ] && echo "YES" || echo "NO")"
          echo "Response first 100 chars: ${RESPONSE:0:100}"
          echo "‚ïê‚ïê‚ïê Full Gemini AI Response ‚ïê‚ïê‚ïê"
          echo "$RESPONSE"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Additional debug: Check if response is actually empty
          if [ -z "$RESPONSE" ]; then
            echo "üö® ERROR: Response is completely empty!"
            echo "Available step outputs:"
            echo "- lint_passed: ${{ steps.lint.outputs.lint_passed }}"
            echo "- lint_errors: ${{ steps.lint.outputs.lint_errors }}"
            echo "Checking if ai_lint_triage step actually ran..."
            exit 1
          fi
          
          # üîß Robust parsing with pattern matching
          if echo "$RESPONSE" | grep -iq "AUTOMATIC_FIX:"; then
            echo "‚úÖ Detected: AUTOMATIC_FIX pattern found"
            echo "fix_type=automatic" >> $GITHUB_OUTPUT
            
            # Extract content *after* the keyword, handle markdown code blocks
            FIX_COMMANDS=$(echo "$RESPONSE" | sed -n '/AUTOMATIC_FIX:/I,$p' | tail -n +2 | sed 's/^```[a-z]*//; s/^```//; s/```$//' | sed '/^[[:space:]]*$/d' | sed 's/^[[:space:]]*//')
            
            echo "fix_commands<<EOF" >> $GITHUB_OUTPUT
            echo "$FIX_COMMANDS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "üìù Extracted Commands:"
            echo "$FIX_COMMANDS"
          elif echo "$RESPONSE" | grep -iq "MANUAL_SUGGESTION:"; then
            echo "‚úÖ Detected: MANUAL_SUGGESTION pattern found"
            echo "fix_type=manual" >> $GITHUB_OUTPUT
            
            # Extract content after the keyword
            SUGGESTION_TEXT=$(echo "$RESPONSE" | sed -n '/MANUAL_SUGGESTION:/I,$p' | tail -n +2)
            
            echo "suggestion_text<<EOF" >> $GITHUB_OUTPUT
            echo "$SUGGESTION_TEXT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "üìù Extracted Suggestion:"
            echo "$SUGGESTION_TEXT"
          else
            # üõ°Ô∏è Graceful Fallback: No keyword found, create manual suggestion with raw output
            echo "‚ö†Ô∏è  Warning: Could not find AUTOMATIC_FIX or MANUAL_SUGGESTION keywords"
            echo "üîÑ Defaulting to manual suggestion mode with full AI response"
            echo "::warning::AI response format unexpected - defaulting to manual suggestion"
            
            echo "fix_type=manual" >> $GITHUB_OUTPUT
            
            # Create fallback text using simple string concatenation
            FALLBACK_TEXT="ü§ñ **AI Response Analysis Required**"
            FALLBACK_TEXT="${FALLBACK_TEXT}\n\n"
            FALLBACK_TEXT="${FALLBACK_TEXT}The AI provided a response but not in the expected format. Please review the full output below and apply fixes manually if needed:\n\n"
            FALLBACK_TEXT="${FALLBACK_TEXT}\`\`\`\n"
            FALLBACK_TEXT="${FALLBACK_TEXT}${RESPONSE}\n"
            FALLBACK_TEXT="${FALLBACK_TEXT}\`\`\`\n\n"
            FALLBACK_TEXT="${FALLBACK_TEXT}*This typically happens when the AI provides explanatory text before the fix commands. Look for actionable commands in the response above.*"
            
            echo "suggestion_text<<EOF" >> $GITHUB_OUTPUT
            printf "%b\n" "$FALLBACK_TEXT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            
            echo "üìù Created fallback suggestion with full AI response"
          fi
          
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "üéØ Final Output: $(grep 'fix_type=' <<< "$GITHUB_OUTPUT" | tail -1 | cut -d'=' -f2 || echo 'unknown')"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      - name: Post Lint Fix Suggestion
        if: steps.handle_gemini_response.outputs.fix_type == 'manual'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          header: ai-lint-suggestion
          message: ${{ steps.handle_gemini_response.outputs.suggestion_text }}

      - name: Verify and Commit Lint Fix
        if: steps.handle_gemini_response.outputs.fix_type == 'automatic'
        run: |
          echo "üöÄ Applying AI-generated fix commands..."
          echo "Commands to execute:"
          echo "${{ steps.handle_gemini_response.outputs.fix_commands }}"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          
          # Execute the AI-generated commands
          ${{ steps.handle_gemini_response.outputs.fix_commands }}
          
          echo "‚úÖ AI fix commands executed successfully"
          echo "üîç Verifying fix by re-running the linter..."
          if ! bun run lint; then
            echo "‚ùå AI fix did not resolve linting errors. Failing workflow."
            exit 1
          fi
          
          echo "Linting errors fixed successfully. Committing changes..."
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore(ci): apply automatic linting fixes"
          git push

      - name: Type check
        run: bun run type-check

      - name: Run unit tests
        run: bun run test
        env:
          DATABASE_URL: file:./test/tmp/ci-test.db
          REDIS_URL: redis://localhost:6379
          NODE_ENV: test

      - name: Run E2E tests
        run: bun run test:e2e
        env:
          DATABASE_URL: file:./test/tmp/ci-test.db
          REDIS_URL: redis://localhost:6379
          NODE_ENV: test

      - name: Build applications
        run: bun run build

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./apps/api/coverage/lcov.info
          flags: backend
          name: backend-coverage

  security:
    name: Security Audit
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Run security audit
        run: bun audit

      - name: Run dependency review
        uses: actions/dependency-review-action@v4
        if: github.event_name == 'pull_request'

  docker:
    name: Docker Build Test
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        run: docker build -t talent-radar-api:test -f apps/api/Dockerfile .
